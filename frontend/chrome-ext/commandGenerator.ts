import { getUniqueSelector, getQuerySelector } from './html_utils';
import type { ActionType, AssertionType, ActionOptions } from './playwrightCodegen';

/**
 * Command Generator Utility
 * 
 * Generates multiple Playwright command variants using different selector strategies.
 * Strategies are conditionally applied based on element properties.
 */

// Helper to add unique commands to array
function addUnique(commands: string[], seenCommands: Set<string>, cmd: string): void {
  if (!seenCommands.has(cmd)) {
    seenCommands.add(cmd);
    commands.push(cmd);
  }
}

// Helper to escape text for Playwright selectors
function escapeText(text: string | null | undefined): string {
  if (!text) return '';
  const jsonEscaped = JSON.stringify(text);
  return jsonEscaped.slice(1, -1);
}

function quote(text: string | null | undefined): string {
  return '`' + escapeText(text) + '`';
}

// Get effective ARIA role (explicit or implicit)
function getEffectiveRole(el: HTMLElement): string | null {
  const explicitRole = el.getAttribute('role');
  if (explicitRole) return explicitRole;
  
  const tagName = el.tagName.toLowerCase();
  const implicitRoles: Record<string, string> = {
    'button': 'button',
    'a': 'link',
    'input': getInputRole(el as HTMLInputElement),
    'textarea': 'textbox',
    'select': 'combobox',
    'nav': 'navigation',
    'main': 'main',
    'header': 'banner',
    'footer': 'contentinfo',
    'aside': 'complementary',
    'form': 'form',
    'img': 'img',
    'h1': 'heading',
    'h2': 'heading',
    'h3': 'heading',
    'h4': 'heading',
    'h5': 'heading',
    'h6': 'heading',
  };
  
  return implicitRoles[tagName] || null;
}

function getInputRole(el: HTMLInputElement): string {
  const type = el.type || 'text';
  const typeRoles: Record<string, string> = {
    'button': 'button',
    'checkbox': 'checkbox',
    'radio': 'radio',
    'range': 'slider',
    'search': 'searchbox',
  };
  return typeRoles[type] || 'textbox';
}

// Get accessible name for element
function getAccessibleName(el: HTMLElement): string | null {
  const ariaLabel = el.getAttribute('aria-label');
  if (ariaLabel) return ariaLabel.trim();
  
  const title = el.getAttribute('title');
  if (title) return title.trim();
  
  const alt = el.getAttribute('alt');
  if (alt) return alt.trim();
  
  const ariaLabelledBy = el.getAttribute('aria-labelledby');
  if (ariaLabelledBy) {
    const labelEl = document.getElementById(ariaLabelledBy);
    if (labelEl) return labelEl.textContent?.trim() || null;
  }
  
  // For form elements, check associated label
  if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement || el instanceof HTMLSelectElement) {
    const labels = (el as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement).labels;
    if (labels && labels.length > 0) {
      return labels[0].textContent?.trim() || null;
    }
  }
  
  return null;
}

// Get visible text from element
function getVisibleText(el: HTMLElement): string | null {
  let text = '';
  for (const node of el.childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  }
  text = text.trim();
  
  if (!text) {
    text = el.textContent?.trim() || '';
  }
  
  if (text.length > 100) return null;
  if (text.length === 0) return null;
  
  return text;
}

// Check if element has meaningful ID (not auto-generated)
function hasMeaningfulId(id: string): boolean {
  if (!id) return false;
  
  if (id.includes('-') || id.includes('_')) return true;
  
  const autoGeneratedPatterns = [
    /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i,
    /^[a-f0-9]{32}$/i,
    /^[a-f0-9]{40}$/i,
    /^[a-f0-9]{64}$/i,
    /^[a-f0-9]{12,}$/i,
    /^react-[a-z0-9]{6,}$/i,
    /^ember[0-9]+$/i,
    /^vue-[a-z0-9]{6,}$/i,
  ];
  
  return !autoGeneratedPatterns.some(pattern => pattern.test(id));
}

// Check if selector has multiple matches
function hasMultipleMatches(selector: string): boolean {
  try {
    const matches = document.querySelectorAll(selector);
    return matches.length > 1;
  } catch {
    return false;
  }
}

// Get parent selector for chaining
function getParentSelector(el: HTMLElement): string | null {
  const parent = el.parentElement;
  if (!parent) return null;
  
  if (parent.id && hasMeaningfulId(parent.id)) {
    return `#${parent.id}`;
  }
  
  if (parent.hasAttribute('data-testid')) {
    return `[data-testid="${parent.getAttribute('data-testid')}"]`;
  }
  
  if (parent.hasAttribute('role')) {
    return `[role="${parent.getAttribute('role')}"]`;
  }
  
  return null;
}

/**
 * Generate multiple locator strings using different selector strategies
 * @param element - The target element
 * @param excludeText - If true, skip getByText strategy (used for assertions with toHaveText)
 * @returns Array of locator strings
 */
export function generateLocators(element: HTMLElement, excludeText: boolean = false): string[] {
  const locators: string[] = [];
  const seenLocators = new Set<string>();
  
  // Strategy 1: Data test attributes
  const testAttrs = ['data-testid', 'data-test-id', 'data-test', 'data-id', 'data-cy', 'data-qa'];
  for (const attr of testAttrs) {
    const val = element.getAttribute(attr);
    if (val && val.trim()) {
      const locator = `page.getByTestId(${quote(val.trim())})`;
      addUnique(locators, seenLocators, locator);
      break;
    }
  }
  
  // Strategy 2: getByRole with name
  const role = getEffectiveRole(element);
  if (role) {
    const accessibleName = getAccessibleName(element);
    const visibleText = accessibleName || getVisibleText(element);
    
    if (visibleText) {
      const locator = `page.getByRole(${quote(role)}, { name: ${quote(visibleText)} })`;
      addUnique(locators, seenLocators, locator);
    }
  }
  
  // Strategy 3: getByText (skip if excludeText is true)
  if (!excludeText) {
    const text = getVisibleText(element);
    if (text) {
      const locator = `page.getByText(${quote(text)})`;
      addUnique(locators, seenLocators, locator);
    }
  }
  
  // Strategy 4: ID selector
  if (element.id && hasMeaningfulId(element.id)) {
    const locator = `page.locator(${quote('#' + element.id)})`;
    addUnique(locators, seenLocators, locator);
  }
  
  // Strategy 5: Name selector (for form elements)
  const name = element.getAttribute('name');
  if (name && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {
    const locator = `page.locator(${quote('[name="' + name + '"]')})`;
    addUnique(locators, seenLocators, locator);
  }
  
  // Strategy 6: CSS selector (fallback - always generate)
  const cssSelector = getUniqueSelector(element);
  if (cssSelector) {
    const locator = `page.locator(${quote(cssSelector)})`;
    addUnique(locators, seenLocators, locator);
  }
  
  // Strategy 7: nth selector (if multiple matches)
  const tagName = element.tagName.toLowerCase();
  if (hasMultipleMatches(tagName)) {
    const siblings = Array.from(document.querySelectorAll(tagName));
    const index = siblings.indexOf(element);
    if (index >= 0) {
      const locator = `page.locator(${quote(tagName)}).nth(${index})`;
      addUnique(locators, seenLocators, locator);
    }
  }
  
  // Strategy 8: first selector (if it's the first match)
  if (cssSelector && hasMultipleMatches(cssSelector)) {
    const matches = document.querySelectorAll(cssSelector);
    if (matches[0] === element) {
      const locator = `page.locator(${quote(cssSelector)}).first()`;
      addUnique(locators, seenLocators, locator);
    }
  }
  
  // Strategy 9: Parent chaining (if selector isn't unique)
  if (cssSelector && hasMultipleMatches(cssSelector)) {
    const parentSel = getParentSelector(element);
    if (parentSel) {
      const childSel = element.tagName.toLowerCase();
      const locator = `page.locator(${quote(parentSel + ' > ' + childSel)})`;
      addUnique(locators, seenLocators, locator);
    }
  }
  
  // Ensure at least one locator is generated
  if (locators.length === 0 && cssSelector) {
    const locator = `page.locator(${quote(cssSelector)})`;
    addUnique(locators, seenLocators, locator);
  }
  
  return locators;
}

/**
 * Generate multiple Playwright commands using different selector strategies
 * @param element - The target element
 * @param actionType - The type of action (click, fill, etc.)
 * @param actionValue - Optional value for the action (e.g., fill value)
 * @param options - Optional action options (button, modifiers)
 * @returns Array of command strings
 */
export function generateMultipleCommands(
  element: HTMLElement,
  actionType: ActionType,
  actionValue?: string | string[],
  options?: ActionOptions
): string[] {
  const locators = generateLocators(element);
  return locators.map(locator => buildActionCommand(locator, actionType, actionValue, options));
}

/**
 * Build action command from locator and action type
 */
function buildActionCommand(
  locator: string,
  actionType: ActionType,
  actionValue?: string | string[],
  options?: ActionOptions
): string {
  // Build options string if provided
  let optsStr = '';
  if (options) {
    const opts: Record<string, any> = {};
    if (options.button && options.button !== 'left') opts.button = options.button;
    if (options.modifiers && options.modifiers.length) opts.modifiers = options.modifiers;
    if (Object.keys(opts).length > 0) {
      optsStr = `, ${JSON.stringify(opts)}`;
    }
  }
  
  switch (actionType) {
    case 'click':
      return `await ${locator}.click(${optsStr ? optsStr.slice(2) : ''});`;
    case 'dblclick':
      return `await ${locator}.dblclick(${optsStr ? optsStr.slice(2) : ''});`;
    case 'fill':
      return `await ${locator}.fill(${quote(actionValue as string)});`;
    case 'type':
      return `await ${locator}.type(${quote(actionValue as string)});`;
    case 'check':
      return `await ${locator}.check();`;
    case 'uncheck':
      return `await ${locator}.uncheck();`;
    case 'selectOption':
      return `await ${locator}.selectOption(${JSON.stringify(actionValue)});`;
    case 'hover':
      return `await ${locator}.hover();`;
    case 'press':
      return `await ${locator}.press(${quote(actionValue as string)});`;
    default:
      return `await ${locator}.${actionType}();`;
  }
}

/**
 * Generate multiple assertion commands using different selector strategies
 */
export function generateMultipleAssertions(
  element: HTMLElement,
  assertionType: AssertionType,
  expectedValue?: string | number
): string[] {
  // Exclude getByText strategy for toHaveText assertions to avoid redundancy
  const excludeText = assertionType === 'toHaveText';
  const locators = generateLocators(element, excludeText);
  return locators.map(locator => buildAssertionCommand(locator, assertionType, expectedValue));
}

/**
 * Build assertion command from locator and assertion type
 */
function buildAssertionCommand(
  locator: string,
  assertionType: AssertionType,
  expectedValue?: string | number
): string {
  switch (assertionType) {
    case 'toBeVisible':
      return `await expect(${locator}).toBeVisible();`;
    case 'toHaveText':
      return `await expect(${locator}).toHaveText(${quote(expectedValue as string)});`;
    case 'toHaveValue':
      return `await expect(${locator}).toHaveValue(${quote(expectedValue as string)});`;
    case 'toBeEnabled':
      return `await expect(${locator}).toBeEnabled();`;
    case 'toBeDisabled':
      return `await expect(${locator}).toBeDisabled();`;
    case 'toHaveCount':
      return `await expect(${locator}).toHaveCount(${expectedValue});`;
    default:
      return `await expect(${locator}).${assertionType}();`;
  }
}

/**
 * Generate navigation commands with different wait strategies
 */
export function generateGotoCommands(url: string): string[] {
  return [
    `await page.goto(${quote(url)});`,
    `await page.goto(${quote(url)}, { waitUntil: 'networkidle' });`,
    `await page.goto(${quote(url)}, { waitUntil: 'load' });`,
  ];
}

