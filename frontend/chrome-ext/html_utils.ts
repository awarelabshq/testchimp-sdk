// Shared HTML element info extraction utilities for both extension and injected scripts

// Enhanced Playwright-style selector generation with better specificity
export function getUniqueSelector(el: HTMLElement): string {
    if (!el) return '';
    
    // 1. Prefer data-testid, data-test-id, data-test, data-id (highest priority)
    const testAttrs = ['data-testid', 'data-test-id', 'data-test', 'data-id', 'data-cy', 'data-qa'];
    for (const attr of testAttrs) {
        const val = el.getAttribute && el.getAttribute(attr);
        if (val && val.trim()) return `[${attr}="${val.trim()}"]`;
    }
    
    // 2. Prefer role with accessible name (ARIA)
    const role = el.getAttribute && el.getAttribute('role');
    if (role) {
        const ariaLabel = el.getAttribute('aria-label');
        const ariaLabelledBy = el.getAttribute('aria-labelledby');
        const title = el.getAttribute('title');
        const alt = el.getAttribute('alt');
        
        let accessibleName = ariaLabel || title || alt;
        
        // If no direct accessible name, try to get it from aria-labelledby
        if (!accessibleName && ariaLabelledBy) {
            const labelEl = document.getElementById(ariaLabelledBy);
            if (labelEl) accessibleName = labelEl.textContent?.trim();
        }
        
        // If still no accessible name, try to get visible text
        if (!accessibleName) {
            const visibleText = getVisibleText(el);
            if (visibleText && visibleText.length > 0 && visibleText.length < 100) {
                accessibleName = visibleText;
            }
        }
        
        if (accessibleName) {
            const cleanName = accessibleName.trim();
            if (cleanName.length > 50) {
                return `role=${role}[name="${cleanName.slice(0, 47)}..."]`;
            }
            return `role=${role}[name="${cleanName}"]`;
        }
        
        // Role without accessible name
        return `role=${role}`;
    }
    
    // 3. Prefer text selector for elements with meaningful text
    const visibleText = getVisibleText(el);
    if (visibleText && visibleText.length > 0 && visibleText.length < 100 && isTextElement(el)) {
        return `text="${visibleText}"`;
    }
    
    // 4. Prefer form elements with name/label
    if (isFormElement(el)) {
        const name = el.getAttribute('name');
        const id = el.getAttribute('id');
        const placeholder = el.getAttribute('placeholder');
        
        if (name) return `[name="${name}"]`;
        if (id) return `#${id}`;
        if (placeholder) return `[placeholder="${placeholder}"]`;
    }
    
    // 5. Prefer elements with meaningful IDs
    if (el.id && isMeaningfulId(el.id)) {
        return `#${el.id}`;
    }
    
    // 6. Use CSS selector with better specificity
    return getCSSSelector(el);
}

// Helper function to get visible text content
function getVisibleText(el: HTMLElement): string {
    const text = el.textContent?.trim() || '';
    if (!text) return '';
    
    // For elements that should have short text (buttons, links, etc.)
    if (['BUTTON', 'A', 'LABEL', 'SPAN', 'DIV'].includes(el.tagName)) {
        return text;
    }
    
    // For other elements, return text if it's reasonable length
    if (text.length <= 100) {
        return text;
    }
    
    return '';
}

// Check if element is a text-based element
function isTextElement(el: HTMLElement): boolean {
    const tagName = el.tagName.toLowerCase();
    return ['button', 'a', 'label', 'span', 'div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName);
}

// Check if element is a form element
function isFormElement(el: HTMLElement): boolean {
    const tagName = el.tagName.toLowerCase();
    return ['input', 'select', 'textarea', 'button'].includes(tagName);
}

// Check if ID is meaningful (not auto-generated)
function isMeaningfulId(id: string): boolean {
    // Skip auto-generated IDs
    const autoGeneratedPatterns = [
        /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i, // UUID
        /^[a-f0-9]{32}$/i, // MD5 hash
        /^[a-f0-9]{40}$/i, // SHA1 hash
        /^[a-f0-9]{64}$/i, // SHA256 hash
        /^[a-z0-9]{8,}$/i, // Random strings
        /^react-/, // React auto-generated
        /^ember/, // Ember auto-generated
        /^vue-/, // Vue auto-generated
    ];
    
    return !autoGeneratedPatterns.some(pattern => pattern.test(id));
}

// Generate CSS selector with better specificity
function getCSSSelector(el: HTMLElement): string {
    if (!el) return '';
    
    // Start with tag name
    let selector = el.tagName.toLowerCase();
    
    // Add ID if meaningful
    if (el.id && isMeaningfulId(el.id)) {
        return `#${el.id}`;
    }
    
    // Add classes (filter out framework-generated classes)
    if (el.className && typeof el.className === 'string') {
        const classes = el.className.trim().split(/\s+/).filter(cls => {
            // Filter out framework-generated classes
            return !cls.match(/^(react-|ember-|vue-|ng-|jquery-)/) && 
                   !cls.match(/^[a-f0-9]{8,}$/) && // Random hex strings
                   cls.length > 1;
        });
        
        if (classes.length > 0) {
            const classPart = classes.join('.');
            selector += `.${classPart}`;
        }
    }
    
    // Add attributes for better specificity
    const importantAttrs = ['name', 'type', 'value', 'placeholder', 'title', 'alt'];
    for (const attr of importantAttrs) {
        const val = el.getAttribute(attr);
        if (val && val.trim()) {
            selector += `[${attr}="${val.trim()}"]`;
            break; // Only add one attribute to keep selector clean
        }
    }
    
    // Add nth-of-type if needed for uniqueness
    if (el.parentElement) {
        const siblings = Array.from(el.parentElement.children).filter(
            (sib) => sib.tagName === el.tagName
        );
        if (siblings.length > 1) {
            const idx = siblings.indexOf(el) + 1;
            selector += `:nth-of-type(${idx})`;
        }
    }
    
    return selector;
}

// Extract all attributes as a key-value map
function getElementAttributesAsKeys(element: HTMLElement): Record<string, any> {
    const attrs: Record<string, any> = {};
    for (let attr of Array.from(element.attributes)) {
        attrs[attr.name] = attr.value;
    }
    return attrs;
}

// Extract a subset or all computed styles as a key-value map
export function getComputedStylesMap(element: HTMLElement): Record<string, string> {
    const style = window.getComputedStyle(element);
    // You can select which properties to include, or include all
    const properties = [
        'color', 'background-color', 'font-size', 'font-weight', 'display', 'visibility', 'opacity',
        'border', 'margin', 'padding', 'width', 'height', 'position', 'top', 'left', 'right', 'bottom',
        'z-index', 'overflow', 'text-align', 'line-height', 'vertical-align', 'box-shadow', 'border-radius'
    ];
    const result: Record<string, string> = {};
    for (const prop of properties) {
        result[prop] = style.getPropertyValue(prop);
    }
    return result;
}

// Parameterized attribute selection
export const BASIC_ATTRS = ['id', 'class', 'name', 'type'];
export function getAttributes(element: HTMLElement, keys: string[] = BASIC_ATTRS): Record<string, string> {
    const attrs: Record<string, string> = {};
    const allAttrs = getElementAttributesAsKeys(element);
    keys.forEach(k => { if (allAttrs[k]) attrs[k] = allAttrs[k]; });
    // Always include data-* attributes
    Object.keys(allAttrs).forEach(k => {
        if (k.startsWith('data-')) attrs[k] = allAttrs[k];
    });
    return attrs;
}

// Parameterized computed style selection
export const BASIC_STYLES = ['color', 'background-color', 'font-size', 'font-weight', 'display'];
export function getComputedStyles(element: HTMLElement, keys: string[] = BASIC_STYLES): Record<string, string> {
    const allStyles = getComputedStylesMap(element);
    const styles: Record<string, string> = {};
    keys.forEach(k => { if (allStyles[k]) styles[k] = allStyles[k]; });
    return styles;
}

// Ancestor hierarchy extraction
export function getAncestorHierarchy(element: HTMLElement, opts?: { full?: boolean }): string {
    const parts: string[] = [];
    let el: HTMLElement | null = element;
    while (el && el !== document.body && el !== document.documentElement) {
        let part = el.tagName.toLowerCase();
        if (el.id) part += `#${el.id}`;
        if (el.className && typeof el.className === 'string') part += `.${el.className.trim().replace(/\s+/g, '.')}`;
        parts.unshift(part);
        el = el.parentElement;
        if (opts && !opts.full && parts.length >= 3) break; // Only 3 levels for short
    }
    return parts.join(' > ');
}

// Returns a valid CSS selector for use with document.querySelector
export function getQuerySelector(el: HTMLElement): string {
    if (!el) return '';
    
    // Use the same enhanced logic as getUniqueSelector but return CSS selector format
    const uniqueSelector = getUniqueSelector(el);
    
    // If it's already a CSS selector, return it
    if (uniqueSelector.startsWith('#') || uniqueSelector.startsWith('[') || uniqueSelector.includes('.')) {
        return uniqueSelector;
    }
    
    // Convert Playwright selectors to CSS selectors
    if (uniqueSelector.startsWith('role=')) {
        const roleMatch = uniqueSelector.match(/role=([^[]+)(?:\[name="([^"]+)"\])?/);
        if (roleMatch) {
            const role = roleMatch[1];
            const name = roleMatch[2];
            if (name) {
                return `[role="${role}"][aria-label="${name}"], [role="${role}"][title="${name}"], [role="${role}"]:has-text("${name}")`;
            }
            return `[role="${role}"]`;
        }
    }
    
    if (uniqueSelector.startsWith('text=')) {
        const textMatch = uniqueSelector.match(/text="([^"]+)"/);
        if (textMatch) {
            const text = textMatch[1];
            return `:has-text("${text}")`;
        }
    }
    
    // Fallback to CSS selector generation
    return getCSSSelector(el);
}

/**
 * Recursively walk the DOM and output a simplified, LLM-friendly JSON structure for bug analytics.
 * - Outputs: tag, key attributes, computed styles (optional), and children (recursive tree)
 * - Prunes noisy elements, skips invisible nodes
 * - Summarizes tables/lists to avoid repetition
 * - Default: maxDepth=12, maxChildren=30, includeStyles=true
 */
export function simplifyDOMForLLM(
  root: HTMLElement = document.body,
  opts?: { maxDepth?: number; maxChildren?: number; includeStyles?: boolean }
): any {
  const maxDepth = opts?.maxDepth ?? 12;
  const maxChildren = opts?.maxChildren ?? 30;
  const includeStyles = opts?.includeStyles ?? true;
  const NOISY_TAGS = new Set([
    'SCRIPT', 'STYLE', 'META', 'LINK', 'NOSCRIPT', 'IFRAME', 'SVG', 'CANVAS', 'HEAD', 'TITLE', 'OBJECT', 'EMBED',
  ]);
  // Subset of computed styles useful for bug analytics
  const STYLE_KEYS = [
    'display', 'visibility', 'color', 'background-color', 'font-size', 'font-weight', 'position', 'z-index',
    'width', 'height', 'overflow', 'opacity', 'border', 'margin', 'padding', 'text-align', 'line-height',
  ];

  function isVisible(el: HTMLElement): boolean {
    const style = window.getComputedStyle(el);
    if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
    if (el.getAttribute('aria-hidden') === 'true') return false;
    let cur: HTMLElement | null = el;
    while (cur) {
      if (cur.hidden) return false;
      cur = cur.parentElement;
    }
    return true;
  }

  function getKeyAttrs(el: HTMLElement): Record<string, string> {
    const attrs: Record<string, string> = {};
    for (const attr of Array.from(el.attributes)) {
      if (/^(id|class|role|name|type|data-|aria-)/.test(attr.name)) {
        attrs[attr.name] = attr.value;
      }
    }
    return attrs;
  }

  function getStyles(el: HTMLElement): Record<string, string> {
    if (!includeStyles) return {};
    const style = window.getComputedStyle(el);
    const out: Record<string, string> = {};
    for (const k of STYLE_KEYS) {
      out[k] = style.getPropertyValue(k);
    }
    return out;
  }

  function getShortText(el: HTMLElement): string | undefined {
    const txt = el.textContent?.trim() || '';
    if (!txt) return undefined;
    if (txt.length > 120) return txt.slice(0, 117) + '...';
    return txt;
  }

  function summarizeTable(table: HTMLTableElement, depth: number): any {
    // Show first row/cell, then summary counts
    const out: any = { tag: 'table', attrs: getKeyAttrs(table) };
    if (includeStyles) out.styles = getStyles(table);
    const rows = Array.from(table.rows);
    if (rows.length > 0) {
      out.firstRow = Array.from(rows[0].cells).map(cell => ({
        tag: cell.tagName.toLowerCase(),
        attrs: getKeyAttrs(cell),
        ...(includeStyles && { styles: getStyles(cell) }),
        text: getShortText(cell),
      }));
    }
    out.rowCount = rows.length;
    out.colCount = rows[0]?.cells.length || 0;
    return out;
  }

  function summarizeList(list: HTMLElement, depth: number): any {
    // Show first 3 items, then summary count
    const out: any = { tag: list.tagName.toLowerCase(), attrs: getKeyAttrs(list) };
    if (includeStyles) out.styles = getStyles(list);
    const items = Array.from(list.children).filter(
      el => el.tagName === 'LI'
    ) as HTMLElement[];
    out.items = items.slice(0, 3).map(li => ({
      tag: 'li',
      attrs: getKeyAttrs(li),
      ...(includeStyles && { styles: getStyles(li) }),
      text: getShortText(li),
    }));
    if (items.length > 3) out.moreItems = items.length - 3;
    return out;
  }

  function walk(el: HTMLElement, depth: number): any {
    if (depth > maxDepth) return undefined;
    if (NOISY_TAGS.has(el.tagName)) return undefined;
    if (!isVisible(el)) return undefined;
    // Table summarization
    if (el.tagName === 'TABLE') return summarizeTable(el as HTMLTableElement, depth);
    // List summarization
    if ((el.tagName === 'UL' || el.tagName === 'OL') && el.children.length > 10) return summarizeList(el, depth);
    const node: any = {
      tag: el.tagName.toLowerCase(),
      attrs: getKeyAttrs(el),
    };
    if (includeStyles) node.styles = getStyles(el);
    const label = el.getAttribute('aria-label') || el.getAttribute('alt') || el.getAttribute('title');
    if (label) node.label = label;
    const text = getShortText(el);
    if (text) node.text = text;
    // Children
    const children: any[] = [];
    let count = 0;
    for (const child of Array.from(el.children)) {
      if (count >= maxChildren) break;
      const c = walk(child as HTMLElement, depth + 1);
      if (c) {
        children.push(c);
        count++;
      }
    }
    if (children.length > 0) node.children = children;
    return node;
  }

  return walk(root, 0);
}

// Add other shared helpers here as needed (attribute extraction, style extraction, ancestor hierarchy, etc.) 